# AutoQuick - руководство по использованию

AutoQuick - это одно-файловый быстрый загрузчик классов для PHP, не имеющий никаких зависимостей. Достаточно включить этот файл в проект при помощи `require_once` из любого места.

## Простейший способ запуска

```php
require_once 'AutoQuick.php'; // подключаем файл
new \AutoQuick([... соответствия ...]); // инициализируем соответствия. Всё!
```

## Правила задания соответствий

### Прямые соответствия классов и файлов

Чтобы указать прямое соответствие полного имени класса и имени файла, в ключе должны быть разделителями обратные слэши `\`, т.е. точно так же как в namespace:

```php
\AutoQuick::$classesArr["full\Class\Name"] = filePath
```

Если имя класса точно соответствует ключу в массиве, то соответствие сразу считается найденным. Иначе - начинается поиск по пространствам имён.

Самый быстрый и действенный способ - указывать точное соответствие файла для каждого класса. В этом случае автозагрузка достигнет цели за минимум шагов.

Для классов в корневом пространстве имён требуется указания обратного слэша в начале имени класса.
Иначе возникает неоднозначность, относится ли ключ к пространству имён или имени класса в корневом пространстве имён.
Поэтому специально для корневого пространства имён добавляется бэк-слэш в начале класса. Например:

```php
\AutoQuick::$classesArr["\DataBase"] = filePath
```

### Поиск пространства имён

Можно указать левую часть пространства имён, которое будет соответствовать более длинными именам классов. В этом случае ключ должен содержать разделителями прямые слэши `/`, т.е. НЕ как в namespace, а как в путях папок:

```php
\AutoQuick::$classesArr['MyNamespace/SubNamespace'] = 'path/to/classes/'
```

Поиск ключей для пространств имён ведётся от более длинных к более коротким, т.е. справа налево. То есть более длинные соответствия имеют приоритет.

## Шаблоны имени файла

Шаблоны имён файлов обрабатываются как при работе с пространствами имён, так и при указании точного соотоветствия имени класса и файла. Это очень быстрые подстановки.

### 1. Специальные символы в начале пути

Первый символ (слева) - специальный, он может заменяться на путь, указанный в массиве подстановок путей `$classesBaseDirArr`. При этом есть несколько особых символов, назначение которых предустановлено:

- **`*`** - указание абсолютного пути (сам символ `*` при этом заменяется на пустую строку), далее после знака `*` может быть указан абсолютный путь. Подстановки связанные с именем класса при этом тоже будут обрабатываться.
- **`/`** - указание абсолютного linux-пути. Символ `/` не определяется в массиве подстановок, поэтому он в начале пути никак не меняется, и путь используется точно как указан. Подстановки связанные с именем класса НЕ обрабатываются. Но знак `#` обрабатывается в любом случае. Аналогично будет работать любой другой символ, не присутствующий ключом в массиве `$classesBaseDirArr`.
- **`~`** - заменяется на корневой путь папки классов. Задаётся заранее в константе `CLASSES_DIR`, либо передаётся параметром во время инициализации `new \AutoQuick`.
- **`?`** - для создания алиасов классов, см. подробности ниже.
- **`&`** - для вызова функций дополнительной обработки, подробности ниже.

Если первый символ не определен в массиве `$classesBaseDirArr`, то он не меняется.

> Далее речь пойдет о символых внутри строки. Обратите внимание, что символы в самом начале строки-шаблона имеют значение, описанное выше, а НЕ в начале строки они имеют совершенно иной смысл.

### 2. Символ '#' для двух-вариантной логики

При помощи символа `#` реализуется двух-вариантная логика загрузки. Суть в том, что один и тот же класс может быть реализован в нескольких разных вариантах, и если найдётся более подходящий вариант, то он загрузится вместо "по умолчанию". А если более подходящий вариант не найдётся, то загрузится "по умолчанию".

**Как работает #-логика:**

- Если в шаблоне встречается символ '#', то он заменяется на значение `self::$lang_cur`, означающее наиболее предпочтительный вариант.
- Проверяется наличие файла по такому пути. Если файл есть, то он будет загружен
- Если файла нет, то символ '#' заменяется на значение `self::$lang_def` и это будет конечным результатом подстановок.

> Имена переменных `$lang_cur` и `$lang_def` намекают, что основное назначение этой логики - загрузка класса на предпочтительном для юзера языке, если такой вариант существует. Если отсутствует, тогда загрузится класс на языке (language) "по умолчанию".

### 3. Добавление .php в конце пути

Если в конце пути не будет `.php`, это расширение будет добавлено автоматически. Если `.php` уже есть, то повторно добавлено не будет.

### 4. Символы подстановки имени класса

- **`?`** - Короткое имя класса (крайне правая часть от полного имени класса).
- **`*`** - Внутренняя часть имени класса. Заменяется на то, что левее короткого имени класса, но правее части имени класса, совпавшей с ключом пространства имён. Предназначение - обработка длинных многокомпонентных имён классов.

> Обратите внимание, что смысл знаков в начале пути отличается от их смысла НЕ в начале пути.
> Обратите внимание, что подстановки имени класса и добавление `.php` работают только если символ в начале пути присутствует в массиве `$classesBaseDirArr`.

### 5. Обработка слэшей

Не боимся возникновения нескольких слепленных слэшей "//" при подстановках, они будут преобразованы к одинарным слешам "/".

> Слепленные слэши удаляются всегда, на конечном этапе обработки пути.
> Двойной слэш `//` в самом начале пути НЕ удаляется, т.к. это может быть сетевой путь.

## Примеры

### Базовый пример

```php
define('CLASSES_DIR, 'путь к корневой папке классов'); // попадает в знак '~'
require_once 'AutoQuick.php';
new \AutoQuick([
    '' => '~/?/?',  // шаблон по умолчанию для "всех остальных" классов
    'MyApp' => '~/src/MyApp/*/?',
    'MyApp\\Controllers' => '~/src/MyApp/Controllers/?',
    'MyApp\\Models' => '~/src/MyApp/Models/?'
]);
```

## Использование &-функций

AutoQuick поддерживает вызов пользовательских функций через символ `&` в начале пути, для сколь угодно гибкого определения пути к файлу класса . Это позволяет реализовать сложную логику загрузки классов, которая не может быть выражена простыми шаблонами.

### Как работают &-функции

Когда в шаблоне пути первый символ `&`, дальнейшая часть строки интерпретируется как имя функции для вызова. Функция получает в качестве параметра массив значений и должна вернуть путь к файлу класса или пустую строку, если класс не найден.

### Параметры, передаваемые в функцию

Функция получает на вход массив значений со следующими ключами:

- **`filePathString`** - часть строки после разделителя `&`, либо пустая строка (если разделителя нет)
- **`classFullName`** - полное имя класса с обратными слэшами. С бэкслэшем в начале, если класс в корневом namespace.
- **`starPath`** - внутренняя часть имени класса (между найденным namespace и коротким именем класса)
- **`classShortName`** - короткое имя класса (без остального namespace)
- **`nameSpaceDir`** - namespace (без короткого имени класса), в формате с прямыми слэшами
- **`nameSpaceKey`** - найденный ключ в массиве соответствий, значение по которому вызвало эту функцию.

### Примеры использования &-функций

```php
// Простая функция, возвращающая статический путь
function getClassPath(array $params): string {
    return '/path/to/classes/MyClass.php';
}

// Функция с логикой на основе параметров
function smartClassLoader(array $params): string {
    $className = $params['classShortName'];
    $namespace = $params['nameSpaceDir'];
  
    // Разная логика для разных пространств имён
    if (strpos($namespace, 'Controllers') !== false) {
        return "/app/controllers/{$className}.php";
    } elseif (strpos($namespace, 'Models') !== false) {
        return "/app/models/{$className}.php";
    }
  
    return "/app/classes/{$className}.php";
}

// Настройка AutoQuick
$classesArr = [
    'MyApp\\Controllers\\UserController' => '&smartClassLoader',
    'MyApp\\Models\\User' => '&smartClassLoader',
    'LegacyClass' => '&getClassPath'
];

new \AutoQuick($classesArr, __DIR__);
```

### Передача дополнительных параметров

Можно передать дополнительные параметры в функцию, используя разделитель `&`:

```php
$classesArr = [
    'SpecialClass' => '&myFunction&param1,param2,param3'
];

function myFunction(array $params): string {
    // $params['filePathString'] будет содержать 'param1,param2,param3'
    $additionalParams = explode(',', $params['filePathString']);
    // ... логика обработки
    return '/path/to/class.php';
}
```

### Обработка ошибок

Если функция возвращает пустую строку или путь к несуществующему файлу, класс не будет загружен. Это позволяет реализовать условную загрузку классов:

```php
function conditionalLoader(array $params): string {
    $className = $params['classShortName'];
  
    // Проверяем, существует ли файл в разных местах
    $paths = [
        "/app/classes/{$className}.php",
        "/legacy/classes/{$className}.php",
        "/vendor/classes/{$className}.php"
    ];
  
    foreach ($paths as $path) {
        if (file_exists($path)) {
            return $path;
        }
    }
  
    return ''; // Класс не найден
}
```

### Настройка базовых директорий для &-функций

```php
\AutoQuick::$classesBaseDirArr = [
    '&' => '',  // для &-функций должен быть пустой
    // ... другие настройки
];
```

## Использование алиасов

AutoQuick поддерживает создание алиасов для классов через символ `?` в начале пути. Это позволяет использовать один и тот же класс под разными именами. Реализуется это через стандартную php-функцию class_alias, которая именно для этого и предназначена.

### Как работают алиасы

Когда в шаблоне пути первый символ `?`, вся дальнейшая часть строки интерпретиируется как имя класса-источника для создания алиаса. Иными словами, в качестве источника указывается не имя файла, а имя класса, для которого будет создана "копия" (а точнее, альтернативное имя). Один и тот же класс может иметь сколько угодно альтернативных имён.

При указании имени класса-источника для class_alias это имя должно быть в стандартном php-формате, то есть с обратными слэшами-разделителями пространства имён.

### Примеры использования алиаса

```php
$classesArr = [
    'OldClass' => '?NewClass',  // создаст алиас OldClass для NewClass
    'NewClass' => '~/classes/NewClass.php'
];

new \AutoQuick($classesArr, __DIR__);

// Теперь можно использовать оба имени класса взаимозаменяемо:
$obj1 = new OldClass();  // фактически создаст NewClass
$obj2 = new NewClass();  // создаст NewClass напрямую
```

### Алиас для класса в корневом пространстве имён

При использовании классов из старого кода эти классы обычно работают в корневом пространстве имён,
и нередко возникает ситуация, когда при обращении к таким классам не указывается бэкслэш в начале имени. Вызывается, например, класс `DataBase` вместо `\DataBase`. Это может создавать проблемы, если код вызова исполняется не в корневом пространстве имён. Эту проблему можно решить
при помощи создания алиаса примерно следующим образом:

```php
$classesArr = [
    '\Database' => 'путь к файлу с классом Database', // проблемный класс в корневом пространстве
    'My\Namespace\Database' => '?\Database' // алиас на случай ошибочного вызова без бэк-слэша
];
```

В данном случае, если из кода в namespace `My\Namespace` будет вызов `Database` без обратного слэша,
фактически будет вызываться класс `My\Namespace\Database`, и автозагрузчик создат для него алиас
на класс `\Database` в корневом пространстве имён, и поэтому код не сломается.

## Пример настройки базовых директорий

```php
\AutoQuick::$classesBaseDirArr = [
    '*' => '',           // для абсолютных путей, должен быть пустой
    '~' => '/var/www/html/classes',  // корневая директория классов
    '?' => '',           // для алиасов, должен быть пустой
    '&' => '',           // для функций, должен быть пустой
];
```

## Корневая директории классов

AutoQuick подставляет корневую директорию классов вместо знака `~` в начале пути.

Директория классов задаётся при инициализации автозагрузчика следующим образом:

1. Если заранее определена константа `CLASSES_DIR` - используется она
2. Если параметром передан путь к директории, то используется она
3. Если передан путь к файлу - используется директория этого файла
4. Если константа не определена и параметр не указан (или пустой), то используется директория в которой лежит сам файл автозагрузчика, предполагается что это и есть корневая директория классов.

> лучший способ - определение константы `CLASSES_DIR`, поскольку в этом случае не выполняется никаких дополнительных шагов по вычислению пути.
>
> корневую директорию классов можно в любой момент переопределить изменив ключ в массиве `\AutoQuick::$classesBaseDirArr['~'] = 'любой другой путь';`. Аналогично можно привязать ещё какие-нибудь другие символы для подстановки каких-то путей.

## Регистрация автозагрузчика

Автозагрузчик автоматически регистрируется при подключении файла `AutoQuick.php`, поскольку в конце этого файла присутствует строка:

```php
spl_autoload_register('AutoQuick::autoLoadSpl', true, true);
```

Автозагрузчик ставит себя в начало очереди автозагрузчиков, если есть другие.

## Дополнительные методы

### \AutoQuick::autoLoad()

При помощи этого вызова с указанием дополнительного параметра `false`, можно
получить вычисленный путь к соответствующему файлу, но не загружать его.
Это можно использовать, например, для проверки, соответствует ли вычисляемое загрузчиком имя
файла тому имени, которое ожидается получить в результате выполнения всех подстановок.

```php
// Получить путь к файлу без его загрузки
$filePath = \AutoQuick::autoLoad('полное\имя\класса', false);
```
